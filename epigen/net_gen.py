"""
Copied and fixed functions from networkx
"""
import math
from itertools import combinations

import networkx as nx

try:
    from scipy.spatial import cKDTree as KDTree
except ImportError:
    _IS_SCIPY_AVAILABLE = False
else:
    _IS_SCIPY_AVAILABLE = True

def _fast_edges(G, radius, p):
    """Returns edge list of node pairs within `radius` of each other
       using scipy KDTree and Minkowski distance metric `p`
    Requires scipy to be installed.
    """
    pos = nx.get_node_attributes(G, "pos")
    nodes, coords = list(zip(*pos.items()))
    kdtree = KDTree(coords)  # Cannot provide generator.
    edge_indexes = kdtree.query_pairs(radius, p)
    edges = ((nodes[u], nodes[v]) for u, v in edge_indexes)
    return edges

def soft_random_geometric_graph(
    n, radius, dim=2, pos=None, p=2, p_dist=None, seed=None
):
    r"""Returns a soft random geometric graph in the unit cube.
    The soft random geometric graph [1] model places `n` nodes uniformly at
    random in the unit cube in dimension `dim`. Two nodes of distance, `dist`,
    computed by the `p`-Minkowski distance metric are joined by an edge with
    probability `p_dist` if the computed distance metric value of the nodes
    is at most `radius`, otherwise they are not joined.
    Edges within `radius` of each other are determined using a KDTree when
    SciPy is available. This reduces the time complexity from :math:`O(n^2)`
    to :math:`O(n)`.
    Parameters
    ----------
    n : int or iterable
        Number of nodes or iterable of nodes
    radius: float
        Distance threshold value
    dim : int, optional
        Dimension of graph
    pos : dict, optional
        A dictionary keyed by node with node positions as values.
    p : float, optional
        Which Minkowski distance metric to use.
        `p` has to meet the condition ``1 <= p <= infinity``.
        If this argument is not specified, the :math:`L^2` metric
        (the Euclidean distance metric), p = 2 is used.
        This should not be confused with the `p` of an Erdős-Rényi random
        graph, which represents probability.
    p_dist : function, optional
        A probability density function computing the probability of
        connecting two nodes that are of distance, dist, computed by the
        Minkowski distance metric. The probability density function, `p_dist`,
        must be any function that takes the metric value as input
        and outputs a single probability value between 0-1. The scipy.stats
        package has many probability distribution functions implemented and
        tools for custom probability distribution definitions [2], and passing
        the .pdf method of scipy.stats distributions can be used here.  If the
        probability function, `p_dist`, is not supplied, the default function
        is an exponential distribution with rate parameter :math:`\lambda=1`.
    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.
    Returns
    -------
    Graph
        A soft random geometric graph, undirected and without self-loops.
        Each node has a node attribute ``'pos'`` that stores the
        position of that node in Euclidean space as provided by the
        ``pos`` keyword argument or, if ``pos`` was not provided, as
        generated by this function.
    Examples
    --------
    Default Graph:
    G = nx.soft_random_geometric_graph(50, 0.2)
    Custom Graph:
    Create a soft random geometric graph on 100 uniformly distributed nodes
    where nodes are joined by an edge with probability computed from an
    exponential distribution with rate parameter :math:`\lambda=1` if their
    Euclidean distance is at most 0.2.
    Notes
    -----
    This uses a *k*-d tree to build the graph.
    The `pos` keyword argument can be used to specify node positions so you
    can create an arbitrary distribution and domain for positions.
    For example, to use a 2D Gaussian distribution of node positions with mean
    (0, 0) and standard deviation 2
    The scipy.stats package can be used to define the probability distribution
    with the .pdf method used as `p_dist`.
    ::
    >>> import random
    >>> import math
    >>> n = 100
    >>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}
    >>> p_dist = lambda dist: math.exp(-dist)
    >>> G = nx.soft_random_geometric_graph(n, 0.2, pos=pos, p_dist=p_dist)
    References
    ----------
    .. [1] Penrose, Mathew D. "Connectivity of soft random geometric graphs."
           The Annals of Applied Probability 26.2 (2016): 986-1028.
       [2] scipy.stats -
           https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html
    """
    nodes = tuple(range(n))
    G = nx.Graph()
    G.name = f"soft_random_geometric_graph({n}, {radius}, {dim})"
    G.add_nodes_from(nodes)
    # If no positions are provided, choose uniformly random vectors in
    # Euclidean space of the specified dimension.
    if pos is None:
        pos = {v: [seed.random() for i in range(dim)] for v in nodes}
    nx.set_node_attributes(G, pos, "pos")

    # if p_dist function not supplied the default function is an exponential
    # distribution with rate parameter :math:`\lambda=1`.
    if p_dist is None:

        def p_dist(dist):
            return math.exp(-dist)

    def should_join(pair):
        u, v = pair
        u_pos, v_pos = pos[u], pos[v]
        dist = (sum(abs(a - b) ** p for a, b in zip(u_pos, v_pos))) ** (1 / p)
        # Check if dist <= radius parameter. This check is redundant if scipy
        # is available and _fast_edges routine is used, but provides the
        # check in case scipy is not available and all edge combinations
        # need to be checked
        if dist <= radius:
            return seed.random() < p_dist(dist)
        else:
            return False

    if _IS_SCIPY_AVAILABLE:
        edges = _fast_edges(G, radius, p)
        G.add_edges_from(filter(should_join, sorted(edges)))
    else:
        G.add_edges_from(filter(should_join, sorted(combinations(G, 2))))

    return G